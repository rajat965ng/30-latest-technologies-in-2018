Chapter 13: Concurrency

	-- Concurrency is a decoupling strategy.

	-- Consider these common myths and misconceptions:
		-- Concurrency always improves performance.
			Concurrency can sometimes improve performance, but only when there is a lot of wait time that can be shared between multiple threads or multiple processors.

		-- Design does not change when writing concurrent programs.	
			The decoupling of what from when usually has a huge effect on the structure of the system.

		-- Understanding concurrency issues is not important when working with a container such as a Web or EJB container.	


	-- Challenges
		-- eg. public class X {
			private int lastIdUsed;
				
				public int getNextId() {
					return ++lastIdUsed;
				}
			}		

			we create an instance of X , set the lastIdUsed field to 42, and then share the
			instance between two threads. Now suppose that both of those threads call the method
			getNextId() ; there are three possible outcomes:


		• Thread one gets the value 43, thread two gets the value 44, lastIdUsed is 44.
		• Thread one gets the value 44, thread two gets the value 43, lastIdUsed is 44.
		• Thread one gets the value 43, thread two gets the value 43, lastIdUsed is 43.

		third result occurs when the two threads step on each other. This happens because there are many possible paths that the two threads can take through that one line of Java code, and some of those paths generate incorrect results.

		How many different paths are there?
			we need to understand what the Just-In-Time Compiler does with the generated byte-code, and understand what the Java memory model considers to be atomic.

			working with just the generated byte-code, is that there are 12,870 different possible execution paths 4 for those two threads executing within the getNextId method. If the type of lastIdUsed is changed from int to long , the number of possible paths increases to 2,704,156. Of course most of those paths generate valid results. The problem is that some of them don’t.


	-- Concurrency Defense Principles
		-- Single Responsibility Principle

			• Concurrency-related code has its own life cycle of development, change, and tuning.

			• Concurrency-related code has its own challenges, which are different from and often
				more difficult than nonconcurrency-related code.

			• The number of ways in which miswritten concurrency-based code can fail makes it
				challenging enough without the added burden of surrounding application code.
				
			Recommendation: Keep your concurrency-related code separate from other code. 


		-- Corollary: Limit the Scope of Data
			two threads modifying the same field of a shared object can interfere with each
			other, causing unexpected behavior. One solution is to use the synchronized keyword to
			protect a critical section in the code that uses the shared object.

			The more places shared data can get updated, the more likely
			There will be duplication of effort required to make sure everything is effectively
			guarded (violation of DRY ).	

			Recommendation: Take data encapsulation to heart; severely limit the access of any data that may be shared.


		-- Corollary: Use Copies of Data
			1. In some situations it is possible to copy objects and treat them as read-only.
			2. it might be possible to copy objects, collect results from multiple threads in these copies and then merge the results in a single thread.

		-- Corollary: Threads Should Be as Independent as Possible
			For example, classes that subclass from HttpServlet receive all of their information
			as parameters passed in to the doGet and doPost methods. This makes each Servlet act
			as if it has its own machine. So long as the code in the Servlet uses only local variables,
			there is no chance that the Servlet will cause synchronization problems. Of course,
			most applications using Servlets eventually run into shared resources such as database
			connections.

			Recommendation: Attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors.

		-- Thread-Safe Collections (java.util.concurrent package)
			ConcurrentHashMap implementation performs better than HashMap in nearly all situations. It
			also allows for simultaneous concurrent reads and writes, and it has methods supporting
			common composite operations that are otherwise not thread safe.	


			ReentrantLock: A lock that can be acquired in one method and released in another.
			
			Semaphore: An implementation of the classic semaphore, a lock with a count.
			
			CountDownLatch: A lock that waits for a number of events before releasing all
							threads waiting on it. This allows all threads to have a fair chance
							of starting at about the same time.

		-- Execution Models (different ways to partition behavior in a concurrent application)
			
			Bound Resources: Resources of a fixed size or number used in a concurrent environment. Examples 
							 include database connections and fixed-size read/write buffers.

			Mutual Exclusion: Only one thread can access shared data or a shared resource at a time.

			Starvation: One thread or a group of threads is prohibited from proceeding for an excessively
						 long time or forever. For example, always letting fast-running threads through first could starve out longer running threads if there is no end to the fast-running threads.

			Deadlock: Two or more threads waiting for each other to finish. Each thread has a resource that 
					  the other thread requires and neither can finish until it gets the other resource.
					  First me, First me.

			Livelock: First you, First you		  			 

		-- Beware Dependencies Between Synchronized Methods
		   How ever, if there is more than one synchronized method on the same shared class, then your
			system may be written incorrectly.	

			Recommendation: Avoid using more than one method on a shared object.

			There will be times when you must use more than one method on a shared object. When this is the case, there are three ways to make the code correct:

			• Client-Based Locking—Have the client lock the server before calling the first
			method and make sure the lock’s extent includes code calling the last method.

			• Server-Based Locking—Within the server create a method that locks the server, calls
			all the methods, and then unlocks. Have the client call the new method.

			• Adapted Server—create an intermediary that performs the locking. This is an exam-
			ple of server-based locking, where the original server cannot be changed.


		-- Locks are expensive because they create delays and add overhead. So we don’t want to litter our
			 code with synchronized statements. On the other hand, critical sections must be guarded. So we want to design our code with as few critical sections as possible.

			Some naive programmers try to achieve this by making their critical sections very
			large. However, extending synchronization beyond the minimal critical section increases
			contention and degrades performance. 

			Recommendation: Keep your synchronized sections as small as possible.	

		-- Run with More Threads Than Processors
			To encourage task swapping, run with more threads than processors or cores. The more frequently your tasks swap, the more likely you’ll encounter code that is missing a critical section or causes deadlock.	

		-- Instrument Your Code to Try and Force Failures
			The reason that threading bugs can be infrequent, sporadic, and hard to repeat, is that
			only a very few pathways out of the many thousands of possible pathways through a vul-
			nerable section actually fail.

			This makes detection and debugging very difficult.	

			How might you increase your chances of catching such rare occurrences?
			 You can instrument your code and force it to run in different orderings by adding calls to methods like Object.wait() , Object.sleep() , Object.yield() and Object.priority() .

			 There are two options for code instrumentation:

			• Hand-coded

			Here is an example of doing just that:
			public synchronized String nextUrlOrNull() {
				if(hasNext()) {
					String url = urlGenerator.next();
					Thread.yield(); // inserted for testing.
					updateHasNext();
					return url;
				}
				return null;
			}


			The inserted call to yield() will change the execution pathways taken by the code and
			possibly cause the code to fail where it did not fail before. If the code does break, it was
			not because you added a call to yield() . 17 Rather, your code was broken and this simply
			made the failure evident.

			There are many problems with this approach:
			• How do you know where to put the call and what kind of call to use?
			• Leaving such code in a production environment unnecessarily slows the code down.

			What we need is a way to do this during testing but not in production.




			• Automated

			You could use tools like an Aspect-Oriented Framework, CGLIB, or ASM to programmat-
			ically instrument your code. For example, you could use a class with a single method:

			public class ThreadJigglePoint {
				public static void jiggle() {
				}
			}


			You can add calls to this in various places within your code:

			public synchronized String nextUrlOrNull() {
				if(hasNext()) {
					ThreadJiglePoint.jiggle();
					String url = urlGenerator.next();
					ThreadJiglePoint.jiggle();
					updateHasNext();
					ThreadJiglePoint.jiggle();
					return url;
				}
			return null;
			}


			the ThreadJigglePoint class has a implementation.

			The jiggle() generates a random number to choose between sleeping, yielding, or just falling through. If you run your tests a thousand times with random jiggling, you may root out some flaws.

			The point is to jiggle the code so that threads run in different orderings at different
			times. The combination of well-written tests and jiggling can dramatically increase the
			chance finding errors.

			There is a tool called ConTest, developed by IBM that does something similar, but it
			does so with quite a bit more sophistication.

			Recommendation: Use jiggling strategies to ferret out errors.

























































