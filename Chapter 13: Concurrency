Chapter 13: Concurrency

	-- Concurrency is a decoupling strategy.

	-- Consider these common myths and misconceptions:
		-- Concurrency always improves performance.
			Concurrency can sometimes improve performance, but only when there is a lot of wait time that can be shared between multiple threads or multiple processors.

		-- Design does not change when writing concurrent programs.	
			The decoupling of what from when usually has a huge effect on the structure of the system.

		-- Understanding concurrency issues is not important when working with a container such as a Web or EJB container.	


	-- Challenges
		-- eg. public class X {
			private int lastIdUsed;
				
				public int getNextId() {
					return ++lastIdUsed;
				}
			}		

			we create an instance of X , set the lastIdUsed field to 42, and then share the
			instance between two threads. Now suppose that both of those threads call the method
			getNextId() ; there are three possible outcomes:


		• Thread one gets the value 43, thread two gets the value 44, lastIdUsed is 44.
		• Thread one gets the value 44, thread two gets the value 43, lastIdUsed is 44.
		• Thread one gets the value 43, thread two gets the value 43, lastIdUsed is 43.

		third result occurs when the two threads step on each other. This happens because there are many possible paths that the two threads can take through that one line of Java code, and some of those paths generate incorrect results.

		How many different paths are there?
			we need to understand what the Just-In-Time Compiler does with the generated byte-code, and understand what the Java memory model considers to be atomic.

			working with just the generated byte-code, is that there are 12,870 different possible execution paths 4 for those two threads executing within the getNextId method. If the type of lastIdUsed is changed from int to long , the number of possible paths increases to 2,704,156. Of course most of those paths generate valid results. The problem is that some of them don’t.


	-- Concurrency Defense Principles
		-- Single Responsibility Principle

			• Concurrency-related code has its own life cycle of development, change, and tuning.

			• Concurrency-related code has its own challenges, which are different from and often
				more difficult than nonconcurrency-related code.

			• The number of ways in which miswritten concurrency-based code can fail makes it
				challenging enough without the added burden of surrounding application code.
				
			Recommendation: Keep your concurrency-related code separate from other code. 


		-- Corollary: Limit the Scope of Data
			two threads modifying the same field of a shared object can interfere with each
			other, causing unexpected behavior. One solution is to use the synchronized keyword to
			protect a critical section in the code that uses the shared object.

			The more places shared data can get updated, the more likely
			There will be duplication of effort required to make sure everything is effectively
			guarded (violation of DRY ).	

			Recommendation: Take data encapsulation to heart; severely limit the access of any data that may be shared.


		-- Corollary: Use Copies of Data
			1. In some situations it is possible to copy objects and treat them as read-only.
			2. it might be possible to copy objects, collect results from multiple threads in these copies and then merge the results in a single thread.

		-- Corollary: Threads Should Be as Independent as Possible
			For example, classes that subclass from HttpServlet receive all of their information
			as parameters passed in to the doGet and doPost methods. This makes each Servlet act
			as if it has its own machine. So long as the code in the Servlet uses only local variables,
			there is no chance that the Servlet will cause synchronization problems. Of course,
			most applications using Servlets eventually run into shared resources such as database
			connections.

			Recommendation: Attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors.









